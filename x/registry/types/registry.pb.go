// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: kyve/registry/v1beta1/registry.proto

package types

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// BundleProposal ...
type BundleProposal struct {
	// uploader ...
	Uploader string `protobuf:"bytes,1,opt,name=uploader,proto3" json:"uploader,omitempty"`
	// next_uploader ...
	NextUploader string `protobuf:"bytes,2,opt,name=next_uploader,json=nextUploader,proto3" json:"next_uploader,omitempty"`
	// bundle_id ...
	BundleId string `protobuf:"bytes,3,opt,name=bundle_id,json=bundleId,proto3" json:"bundle_id,omitempty"`
	// byte_size ...
	ByteSize uint64 `protobuf:"varint,4,opt,name=byte_size,json=byteSize,proto3" json:"byte_size,omitempty"`
	// from_height ...
	FromHeight uint64 `protobuf:"varint,5,opt,name=from_height,json=fromHeight,proto3" json:"from_height,omitempty"` // Deprecated: Do not use.
	// to_height ...
	ToHeight uint64 `protobuf:"varint,6,opt,name=to_height,json=toHeight,proto3" json:"to_height,omitempty"`
	// created_at ...
	CreatedAt uint64 `protobuf:"varint,7,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	// voters_valid ...
	VotersValid []string `protobuf:"bytes,8,rep,name=voters_valid,json=votersValid,proto3" json:"voters_valid,omitempty"`
	// voters_invalid ...
	VotersInvalid []string `protobuf:"bytes,9,rep,name=voters_invalid,json=votersInvalid,proto3" json:"voters_invalid,omitempty"`
	// voters_abstain ...
	VotersAbstain []string `protobuf:"bytes,10,rep,name=voters_abstain,json=votersAbstain,proto3" json:"voters_abstain,omitempty"`
	// to_key ...
	ToKey string `protobuf:"bytes,11,opt,name=to_key,json=toKey,proto3" json:"to_key,omitempty"`
	// to_value ...
	ToValue string `protobuf:"bytes,12,opt,name=to_value,json=toValue,proto3" json:"to_value,omitempty"`
	// bundle_hash ...
	BundleHash string `protobuf:"bytes,13,opt,name=bundle_hash,json=bundleHash,proto3" json:"bundle_hash,omitempty"`
}

func (m *BundleProposal) Reset()         { *m = BundleProposal{} }
func (m *BundleProposal) String() string { return proto.CompactTextString(m) }
func (*BundleProposal) ProtoMessage()    {}
func (*BundleProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_db13ea1584a90e6e, []int{0}
}
func (m *BundleProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BundleProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BundleProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BundleProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BundleProposal.Merge(m, src)
}
func (m *BundleProposal) XXX_Size() int {
	return m.Size()
}
func (m *BundleProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_BundleProposal.DiscardUnknown(m)
}

var xxx_messageInfo_BundleProposal proto.InternalMessageInfo

func (m *BundleProposal) GetUploader() string {
	if m != nil {
		return m.Uploader
	}
	return ""
}

func (m *BundleProposal) GetNextUploader() string {
	if m != nil {
		return m.NextUploader
	}
	return ""
}

func (m *BundleProposal) GetBundleId() string {
	if m != nil {
		return m.BundleId
	}
	return ""
}

func (m *BundleProposal) GetByteSize() uint64 {
	if m != nil {
		return m.ByteSize
	}
	return 0
}

// Deprecated: Do not use.
func (m *BundleProposal) GetFromHeight() uint64 {
	if m != nil {
		return m.FromHeight
	}
	return 0
}

func (m *BundleProposal) GetToHeight() uint64 {
	if m != nil {
		return m.ToHeight
	}
	return 0
}

func (m *BundleProposal) GetCreatedAt() uint64 {
	if m != nil {
		return m.CreatedAt
	}
	return 0
}

func (m *BundleProposal) GetVotersValid() []string {
	if m != nil {
		return m.VotersValid
	}
	return nil
}

func (m *BundleProposal) GetVotersInvalid() []string {
	if m != nil {
		return m.VotersInvalid
	}
	return nil
}

func (m *BundleProposal) GetVotersAbstain() []string {
	if m != nil {
		return m.VotersAbstain
	}
	return nil
}

func (m *BundleProposal) GetToKey() string {
	if m != nil {
		return m.ToKey
	}
	return ""
}

func (m *BundleProposal) GetToValue() string {
	if m != nil {
		return m.ToValue
	}
	return ""
}

func (m *BundleProposal) GetBundleHash() string {
	if m != nil {
		return m.BundleHash
	}
	return ""
}

// Protocol ...
type Protocol struct {
	// version ...
	Version string `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
	// binaries ...
	Binaries string `protobuf:"bytes,2,opt,name=binaries,proto3" json:"binaries,omitempty"`
	// last_upgrade ...
	LastUpgrade uint64 `protobuf:"varint,3,opt,name=last_upgrade,json=lastUpgrade,proto3" json:"last_upgrade,omitempty"`
}

func (m *Protocol) Reset()         { *m = Protocol{} }
func (m *Protocol) String() string { return proto.CompactTextString(m) }
func (*Protocol) ProtoMessage()    {}
func (*Protocol) Descriptor() ([]byte, []int) {
	return fileDescriptor_db13ea1584a90e6e, []int{1}
}
func (m *Protocol) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Protocol) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Protocol.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Protocol) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Protocol.Merge(m, src)
}
func (m *Protocol) XXX_Size() int {
	return m.Size()
}
func (m *Protocol) XXX_DiscardUnknown() {
	xxx_messageInfo_Protocol.DiscardUnknown(m)
}

var xxx_messageInfo_Protocol proto.InternalMessageInfo

func (m *Protocol) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *Protocol) GetBinaries() string {
	if m != nil {
		return m.Binaries
	}
	return ""
}

func (m *Protocol) GetLastUpgrade() uint64 {
	if m != nil {
		return m.LastUpgrade
	}
	return 0
}

// Upgrade ...
type UpgradePlan struct {
	// version ...
	Version string `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
	// binaries ...
	Binaries string `protobuf:"bytes,2,opt,name=binaries,proto3" json:"binaries,omitempty"`
	// scheduled_at ...
	ScheduledAt uint64 `protobuf:"varint,3,opt,name=scheduled_at,json=scheduledAt,proto3" json:"scheduled_at,omitempty"`
	// duration ...
	Duration uint64 `protobuf:"varint,4,opt,name=duration,proto3" json:"duration,omitempty"`
}

func (m *UpgradePlan) Reset()         { *m = UpgradePlan{} }
func (m *UpgradePlan) String() string { return proto.CompactTextString(m) }
func (*UpgradePlan) ProtoMessage()    {}
func (*UpgradePlan) Descriptor() ([]byte, []int) {
	return fileDescriptor_db13ea1584a90e6e, []int{2}
}
func (m *UpgradePlan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpgradePlan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpgradePlan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpgradePlan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpgradePlan.Merge(m, src)
}
func (m *UpgradePlan) XXX_Size() int {
	return m.Size()
}
func (m *UpgradePlan) XXX_DiscardUnknown() {
	xxx_messageInfo_UpgradePlan.DiscardUnknown(m)
}

var xxx_messageInfo_UpgradePlan proto.InternalMessageInfo

func (m *UpgradePlan) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *UpgradePlan) GetBinaries() string {
	if m != nil {
		return m.Binaries
	}
	return ""
}

func (m *UpgradePlan) GetScheduledAt() uint64 {
	if m != nil {
		return m.ScheduledAt
	}
	return 0
}

func (m *UpgradePlan) GetDuration() uint64 {
	if m != nil {
		return m.Duration
	}
	return 0
}

// DelegationEntries ...
type DelegationEntries struct {
	// id ...
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// balance ...
	Balance string `protobuf:"bytes,2,opt,name=balance,proto3" json:"balance,omitempty"`
	// staker ...
	Staker string `protobuf:"bytes,3,opt,name=staker,proto3" json:"staker,omitempty"`
	// k_index ...
	KIndex uint64 `protobuf:"varint,4,opt,name=k_index,json=kIndex,proto3" json:"k_index,omitempty"`
}

func (m *DelegationEntries) Reset()         { *m = DelegationEntries{} }
func (m *DelegationEntries) String() string { return proto.CompactTextString(m) }
func (*DelegationEntries) ProtoMessage()    {}
func (*DelegationEntries) Descriptor() ([]byte, []int) {
	return fileDescriptor_db13ea1584a90e6e, []int{3}
}
func (m *DelegationEntries) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DelegationEntries) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DelegationEntries.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DelegationEntries) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DelegationEntries.Merge(m, src)
}
func (m *DelegationEntries) XXX_Size() int {
	return m.Size()
}
func (m *DelegationEntries) XXX_DiscardUnknown() {
	xxx_messageInfo_DelegationEntries.DiscardUnknown(m)
}

var xxx_messageInfo_DelegationEntries proto.InternalMessageInfo

func (m *DelegationEntries) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *DelegationEntries) GetBalance() string {
	if m != nil {
		return m.Balance
	}
	return ""
}

func (m *DelegationEntries) GetStaker() string {
	if m != nil {
		return m.Staker
	}
	return ""
}

func (m *DelegationEntries) GetKIndex() uint64 {
	if m != nil {
		return m.KIndex
	}
	return 0
}

// DelegationPoolData ...
type DelegationPoolData struct {
	// id ...
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// staker ...
	Staker string `protobuf:"bytes,2,opt,name=staker,proto3" json:"staker,omitempty"`
	// current_rewards ...
	CurrentRewards uint64 `protobuf:"varint,3,opt,name=current_rewards,json=currentRewards,proto3" json:"current_rewards,omitempty"`
	// total_delegation ...
	TotalDelegation uint64 `protobuf:"varint,4,opt,name=total_delegation,json=totalDelegation,proto3" json:"total_delegation,omitempty"`
	// latest_index_k ...
	LatestIndexK uint64 `protobuf:"varint,5,opt,name=latest_index_k,json=latestIndexK,proto3" json:"latest_index_k,omitempty"`
	// delegator_count ...
	DelegatorCount uint64 `protobuf:"varint,6,opt,name=delegator_count,json=delegatorCount,proto3" json:"delegator_count,omitempty"`
	// latest_index_was_undelegation ...
	LatestIndexWasUndelegation bool `protobuf:"varint,7,opt,name=latest_index_was_undelegation,json=latestIndexWasUndelegation,proto3" json:"latest_index_was_undelegation,omitempty"`
}

func (m *DelegationPoolData) Reset()         { *m = DelegationPoolData{} }
func (m *DelegationPoolData) String() string { return proto.CompactTextString(m) }
func (*DelegationPoolData) ProtoMessage()    {}
func (*DelegationPoolData) Descriptor() ([]byte, []int) {
	return fileDescriptor_db13ea1584a90e6e, []int{4}
}
func (m *DelegationPoolData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DelegationPoolData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DelegationPoolData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DelegationPoolData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DelegationPoolData.Merge(m, src)
}
func (m *DelegationPoolData) XXX_Size() int {
	return m.Size()
}
func (m *DelegationPoolData) XXX_DiscardUnknown() {
	xxx_messageInfo_DelegationPoolData.DiscardUnknown(m)
}

var xxx_messageInfo_DelegationPoolData proto.InternalMessageInfo

func (m *DelegationPoolData) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *DelegationPoolData) GetStaker() string {
	if m != nil {
		return m.Staker
	}
	return ""
}

func (m *DelegationPoolData) GetCurrentRewards() uint64 {
	if m != nil {
		return m.CurrentRewards
	}
	return 0
}

func (m *DelegationPoolData) GetTotalDelegation() uint64 {
	if m != nil {
		return m.TotalDelegation
	}
	return 0
}

func (m *DelegationPoolData) GetLatestIndexK() uint64 {
	if m != nil {
		return m.LatestIndexK
	}
	return 0
}

func (m *DelegationPoolData) GetDelegatorCount() uint64 {
	if m != nil {
		return m.DelegatorCount
	}
	return 0
}

func (m *DelegationPoolData) GetLatestIndexWasUndelegation() bool {
	if m != nil {
		return m.LatestIndexWasUndelegation
	}
	return false
}

// Delegator ...
type Delegator struct {
	// id ...
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// k_index ...
	KIndex uint64 `protobuf:"varint,2,opt,name=k_index,json=kIndex,proto3" json:"k_index,omitempty"`
	// delegation_amount ...
	DelegationAmount uint64 `protobuf:"varint,3,opt,name=delegation_amount,json=delegationAmount,proto3" json:"delegation_amount,omitempty"`
	// staker ...
	Staker string `protobuf:"bytes,4,opt,name=staker,proto3" json:"staker,omitempty"`
	// delegator ...
	Delegator string `protobuf:"bytes,5,opt,name=delegator,proto3" json:"delegator,omitempty"`
}

func (m *Delegator) Reset()         { *m = Delegator{} }
func (m *Delegator) String() string { return proto.CompactTextString(m) }
func (*Delegator) ProtoMessage()    {}
func (*Delegator) Descriptor() ([]byte, []int) {
	return fileDescriptor_db13ea1584a90e6e, []int{5}
}
func (m *Delegator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Delegator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Delegator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Delegator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Delegator.Merge(m, src)
}
func (m *Delegator) XXX_Size() int {
	return m.Size()
}
func (m *Delegator) XXX_DiscardUnknown() {
	xxx_messageInfo_Delegator.DiscardUnknown(m)
}

var xxx_messageInfo_Delegator proto.InternalMessageInfo

func (m *Delegator) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Delegator) GetKIndex() uint64 {
	if m != nil {
		return m.KIndex
	}
	return 0
}

func (m *Delegator) GetDelegationAmount() uint64 {
	if m != nil {
		return m.DelegationAmount
	}
	return 0
}

func (m *Delegator) GetStaker() string {
	if m != nil {
		return m.Staker
	}
	return ""
}

func (m *Delegator) GetDelegator() string {
	if m != nil {
		return m.Delegator
	}
	return ""
}

// Funder ...
type Funder struct {
	// account ...
	Account string `protobuf:"bytes,2,opt,name=account,proto3" json:"account,omitempty"`
	// fund_id ...
	PoolId uint64 `protobuf:"varint,1,opt,name=pool_id,json=poolId,proto3" json:"pool_id,omitempty"`
	// amount ...
	Amount uint64 `protobuf:"varint,3,opt,name=amount,proto3" json:"amount,omitempty"`
}

func (m *Funder) Reset()         { *m = Funder{} }
func (m *Funder) String() string { return proto.CompactTextString(m) }
func (*Funder) ProtoMessage()    {}
func (*Funder) Descriptor() ([]byte, []int) {
	return fileDescriptor_db13ea1584a90e6e, []int{6}
}
func (m *Funder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Funder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Funder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Funder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Funder.Merge(m, src)
}
func (m *Funder) XXX_Size() int {
	return m.Size()
}
func (m *Funder) XXX_DiscardUnknown() {
	xxx_messageInfo_Funder.DiscardUnknown(m)
}

var xxx_messageInfo_Funder proto.InternalMessageInfo

func (m *Funder) GetAccount() string {
	if m != nil {
		return m.Account
	}
	return ""
}

func (m *Funder) GetPoolId() uint64 {
	if m != nil {
		return m.PoolId
	}
	return 0
}

func (m *Funder) GetAmount() uint64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

// Pool ...
type Pool struct {
	// id ...
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// creator ...
	Creator string `protobuf:"bytes,2,opt,name=creator,proto3" json:"creator,omitempty"`
	// name ...
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// runtime ...
	Runtime string `protobuf:"bytes,4,opt,name=runtime,proto3" json:"runtime,omitempty"`
	// logo ...
	Logo string `protobuf:"bytes,5,opt,name=logo,proto3" json:"logo,omitempty"`
	// versions ...
	Versions string `protobuf:"bytes,6,opt,name=versions,proto3" json:"versions,omitempty"` // Deprecated: Do not use.
	// config ...
	Config string `protobuf:"bytes,7,opt,name=config,proto3" json:"config,omitempty"`
	// current_height ...
	CurrentHeight uint64 `protobuf:"varint,8,opt,name=current_height,json=currentHeight,proto3" json:"current_height,omitempty"`
	// total_bytes ...
	TotalBytes uint64 `protobuf:"varint,9,opt,name=total_bytes,json=totalBytes,proto3" json:"total_bytes,omitempty"`
	// total_bundles ...
	TotalBundles uint64 `protobuf:"varint,10,opt,name=total_bundles,json=totalBundles,proto3" json:"total_bundles,omitempty"`
	// total_bundle_rewards ...
	TotalBundleRewards uint64 `protobuf:"varint,11,opt,name=total_bundle_rewards,json=totalBundleRewards,proto3" json:"total_bundle_rewards,omitempty"`
	// start_height ...
	StartHeight uint64 `protobuf:"varint,12,opt,name=start_height,json=startHeight,proto3" json:"start_height,omitempty"` // Deprecated: Do not use.
	// upload_interval ...
	UploadInterval uint64 `protobuf:"varint,13,opt,name=upload_interval,json=uploadInterval,proto3" json:"upload_interval,omitempty"`
	// operating_cost ...
	OperatingCost uint64 `protobuf:"varint,14,opt,name=operating_cost,json=operatingCost,proto3" json:"operating_cost,omitempty"`
	// paused ...
	Paused bool `protobuf:"varint,15,opt,name=paused,proto3" json:"paused,omitempty"`
	// funders ...
	Funders []string `protobuf:"bytes,16,rep,name=funders,proto3" json:"funders,omitempty"`
	// lowest_funder ...
	LowestFunder string `protobuf:"bytes,17,opt,name=lowest_funder,json=lowestFunder,proto3" json:"lowest_funder,omitempty"`
	// total_funds ...
	TotalFunds uint64 `protobuf:"varint,18,opt,name=total_funds,json=totalFunds,proto3" json:"total_funds,omitempty"`
	// stakers ...
	Stakers []string `protobuf:"bytes,19,rep,name=stakers,proto3" json:"stakers,omitempty"`
	// lowest_staker ...
	LowestStaker string `protobuf:"bytes,20,opt,name=lowest_staker,json=lowestStaker,proto3" json:"lowest_staker,omitempty"`
	// total_stake ...
	TotalStake uint64 `protobuf:"varint,21,opt,name=total_stake,json=totalStake,proto3" json:"total_stake,omitempty"`
	// total_delegation ...
	TotalDelegation uint64 `protobuf:"varint,22,opt,name=total_delegation,json=totalDelegation,proto3" json:"total_delegation,omitempty"`
	// bundle_proposal ...
	BundleProposal *BundleProposal `protobuf:"bytes,23,opt,name=bundle_proposal,json=bundleProposal,proto3" json:"bundle_proposal,omitempty"`
	// max_bundle_size ...
	MaxBundleSize uint64 `protobuf:"varint,24,opt,name=max_bundle_size,json=maxBundleSize,proto3" json:"max_bundle_size,omitempty"`
	// protocol ...
	Protocol *Protocol `protobuf:"bytes,25,opt,name=protocol,proto3" json:"protocol,omitempty"`
	// upgrade_plan ...
	UpgradePlan *UpgradePlan `protobuf:"bytes,26,opt,name=upgrade_plan,json=upgradePlan,proto3" json:"upgrade_plan,omitempty"`
	// start_key ...
	StartKey string `protobuf:"bytes,27,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	// current_key ...
	CurrentKey string `protobuf:"bytes,28,opt,name=current_key,json=currentKey,proto3" json:"current_key,omitempty"`
	// current_value ...
	CurrentValue string `protobuf:"bytes,29,opt,name=current_value,json=currentValue,proto3" json:"current_value,omitempty"`
}

func (m *Pool) Reset()         { *m = Pool{} }
func (m *Pool) String() string { return proto.CompactTextString(m) }
func (*Pool) ProtoMessage()    {}
func (*Pool) Descriptor() ([]byte, []int) {
	return fileDescriptor_db13ea1584a90e6e, []int{7}
}
func (m *Pool) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Pool) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Pool.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Pool) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Pool.Merge(m, src)
}
func (m *Pool) XXX_Size() int {
	return m.Size()
}
func (m *Pool) XXX_DiscardUnknown() {
	xxx_messageInfo_Pool.DiscardUnknown(m)
}

var xxx_messageInfo_Pool proto.InternalMessageInfo

func (m *Pool) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Pool) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *Pool) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Pool) GetRuntime() string {
	if m != nil {
		return m.Runtime
	}
	return ""
}

func (m *Pool) GetLogo() string {
	if m != nil {
		return m.Logo
	}
	return ""
}

// Deprecated: Do not use.
func (m *Pool) GetVersions() string {
	if m != nil {
		return m.Versions
	}
	return ""
}

func (m *Pool) GetConfig() string {
	if m != nil {
		return m.Config
	}
	return ""
}

func (m *Pool) GetCurrentHeight() uint64 {
	if m != nil {
		return m.CurrentHeight
	}
	return 0
}

func (m *Pool) GetTotalBytes() uint64 {
	if m != nil {
		return m.TotalBytes
	}
	return 0
}

func (m *Pool) GetTotalBundles() uint64 {
	if m != nil {
		return m.TotalBundles
	}
	return 0
}

func (m *Pool) GetTotalBundleRewards() uint64 {
	if m != nil {
		return m.TotalBundleRewards
	}
	return 0
}

// Deprecated: Do not use.
func (m *Pool) GetStartHeight() uint64 {
	if m != nil {
		return m.StartHeight
	}
	return 0
}

func (m *Pool) GetUploadInterval() uint64 {
	if m != nil {
		return m.UploadInterval
	}
	return 0
}

func (m *Pool) GetOperatingCost() uint64 {
	if m != nil {
		return m.OperatingCost
	}
	return 0
}

func (m *Pool) GetPaused() bool {
	if m != nil {
		return m.Paused
	}
	return false
}

func (m *Pool) GetFunders() []string {
	if m != nil {
		return m.Funders
	}
	return nil
}

func (m *Pool) GetLowestFunder() string {
	if m != nil {
		return m.LowestFunder
	}
	return ""
}

func (m *Pool) GetTotalFunds() uint64 {
	if m != nil {
		return m.TotalFunds
	}
	return 0
}

func (m *Pool) GetStakers() []string {
	if m != nil {
		return m.Stakers
	}
	return nil
}

func (m *Pool) GetLowestStaker() string {
	if m != nil {
		return m.LowestStaker
	}
	return ""
}

func (m *Pool) GetTotalStake() uint64 {
	if m != nil {
		return m.TotalStake
	}
	return 0
}

func (m *Pool) GetTotalDelegation() uint64 {
	if m != nil {
		return m.TotalDelegation
	}
	return 0
}

func (m *Pool) GetBundleProposal() *BundleProposal {
	if m != nil {
		return m.BundleProposal
	}
	return nil
}

func (m *Pool) GetMaxBundleSize() uint64 {
	if m != nil {
		return m.MaxBundleSize
	}
	return 0
}

func (m *Pool) GetProtocol() *Protocol {
	if m != nil {
		return m.Protocol
	}
	return nil
}

func (m *Pool) GetUpgradePlan() *UpgradePlan {
	if m != nil {
		return m.UpgradePlan
	}
	return nil
}

func (m *Pool) GetStartKey() string {
	if m != nil {
		return m.StartKey
	}
	return ""
}

func (m *Pool) GetCurrentKey() string {
	if m != nil {
		return m.CurrentKey
	}
	return ""
}

func (m *Pool) GetCurrentValue() string {
	if m != nil {
		return m.CurrentValue
	}
	return ""
}

// Proposal ...
type Proposal struct {
	// bundle_id ...
	BundleId string `protobuf:"bytes,1,opt,name=bundle_id,json=bundleId,proto3" json:"bundle_id,omitempty"`
	// pool_id ...
	PoolId uint64 `protobuf:"varint,2,opt,name=pool_id,json=poolId,proto3" json:"pool_id,omitempty"`
	// uploader ...
	Uploader string `protobuf:"bytes,3,opt,name=uploader,proto3" json:"uploader,omitempty"`
	// from_height ...
	FromHeight uint64 `protobuf:"varint,4,opt,name=from_height,json=fromHeight,proto3" json:"from_height,omitempty"`
	// to_height ...
	ToHeight uint64 `protobuf:"varint,5,opt,name=to_height,json=toHeight,proto3" json:"to_height,omitempty"`
	// finalized_at ...
	FinalizedAt uint64 `protobuf:"varint,6,opt,name=finalized_at,json=finalizedAt,proto3" json:"finalized_at,omitempty"`
	// id ...
	Id uint64 `protobuf:"varint,7,opt,name=id,proto3" json:"id,omitempty"`
	// key ...
	Key string `protobuf:"bytes,8,opt,name=key,proto3" json:"key,omitempty"`
	// value ...
	Value string `protobuf:"bytes,9,opt,name=value,proto3" json:"value,omitempty"`
	// bundle_hash ...
	BundleHash string `protobuf:"bytes,10,opt,name=bundle_hash,json=bundleHash,proto3" json:"bundle_hash,omitempty"`
}

func (m *Proposal) Reset()         { *m = Proposal{} }
func (m *Proposal) String() string { return proto.CompactTextString(m) }
func (*Proposal) ProtoMessage()    {}
func (*Proposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_db13ea1584a90e6e, []int{8}
}
func (m *Proposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Proposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Proposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Proposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Proposal.Merge(m, src)
}
func (m *Proposal) XXX_Size() int {
	return m.Size()
}
func (m *Proposal) XXX_DiscardUnknown() {
	xxx_messageInfo_Proposal.DiscardUnknown(m)
}

var xxx_messageInfo_Proposal proto.InternalMessageInfo

func (m *Proposal) GetBundleId() string {
	if m != nil {
		return m.BundleId
	}
	return ""
}

func (m *Proposal) GetPoolId() uint64 {
	if m != nil {
		return m.PoolId
	}
	return 0
}

func (m *Proposal) GetUploader() string {
	if m != nil {
		return m.Uploader
	}
	return ""
}

func (m *Proposal) GetFromHeight() uint64 {
	if m != nil {
		return m.FromHeight
	}
	return 0
}

func (m *Proposal) GetToHeight() uint64 {
	if m != nil {
		return m.ToHeight
	}
	return 0
}

func (m *Proposal) GetFinalizedAt() uint64 {
	if m != nil {
		return m.FinalizedAt
	}
	return 0
}

func (m *Proposal) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Proposal) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *Proposal) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *Proposal) GetBundleHash() string {
	if m != nil {
		return m.BundleHash
	}
	return ""
}

// Staker ...
type Staker struct {
	// staker ...
	Account string `protobuf:"bytes,1,opt,name=account,proto3" json:"account,omitempty"`
	// pool_id ...
	PoolId uint64 `protobuf:"varint,2,opt,name=pool_id,json=poolId,proto3" json:"pool_id,omitempty"`
	// amount ...
	Amount uint64 `protobuf:"varint,3,opt,name=amount,proto3" json:"amount,omitempty"`
	// unbonding_amount ...
	UnbondingAmount uint64 `protobuf:"varint,4,opt,name=unbonding_amount,json=unbondingAmount,proto3" json:"unbonding_amount,omitempty"`
	// commission ...
	Commission string `protobuf:"bytes,5,opt,name=commission,proto3" json:"commission,omitempty"`
	// moniker ...
	Moniker string `protobuf:"bytes,6,opt,name=moniker,proto3" json:"moniker,omitempty"`
	// website ...
	Website string `protobuf:"bytes,7,opt,name=website,proto3" json:"website,omitempty"`
	// logo
	Logo string `protobuf:"bytes,8,opt,name=logo,proto3" json:"logo,omitempty"`
	// points
	Points uint64 `protobuf:"varint,9,opt,name=points,proto3" json:"points,omitempty"`
}

func (m *Staker) Reset()         { *m = Staker{} }
func (m *Staker) String() string { return proto.CompactTextString(m) }
func (*Staker) ProtoMessage()    {}
func (*Staker) Descriptor() ([]byte, []int) {
	return fileDescriptor_db13ea1584a90e6e, []int{9}
}
func (m *Staker) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Staker) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Staker.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Staker) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Staker.Merge(m, src)
}
func (m *Staker) XXX_Size() int {
	return m.Size()
}
func (m *Staker) XXX_DiscardUnknown() {
	xxx_messageInfo_Staker.DiscardUnknown(m)
}

var xxx_messageInfo_Staker proto.InternalMessageInfo

func (m *Staker) GetAccount() string {
	if m != nil {
		return m.Account
	}
	return ""
}

func (m *Staker) GetPoolId() uint64 {
	if m != nil {
		return m.PoolId
	}
	return 0
}

func (m *Staker) GetAmount() uint64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *Staker) GetUnbondingAmount() uint64 {
	if m != nil {
		return m.UnbondingAmount
	}
	return 0
}

func (m *Staker) GetCommission() string {
	if m != nil {
		return m.Commission
	}
	return ""
}

func (m *Staker) GetMoniker() string {
	if m != nil {
		return m.Moniker
	}
	return ""
}

func (m *Staker) GetWebsite() string {
	if m != nil {
		return m.Website
	}
	return ""
}

func (m *Staker) GetLogo() string {
	if m != nil {
		return m.Logo
	}
	return ""
}

func (m *Staker) GetPoints() uint64 {
	if m != nil {
		return m.Points
	}
	return 0
}

// UnbondingStakingEntry
// Creates an entry for an upcoming unbonding of a staker which is put in the unbonding fifo queue and
// executed after the unbonding time is over.
type UnbondingStakingQueueEntry struct {
	// index is a monotonically increasing integer to order the entries
	Index uint64 `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	// staker ...
	Staker string `protobuf:"bytes,2,opt,name=staker,proto3" json:"staker,omitempty"`
	// pool_id ...
	PoolId uint64 `protobuf:"varint,3,opt,name=pool_id,json=poolId,proto3" json:"pool_id,omitempty"`
	// amount ...
	Amount uint64 `protobuf:"varint,4,opt,name=amount,proto3" json:"amount,omitempty"`
	// creation_time ...
	CreationTime uint64 `protobuf:"varint,5,opt,name=creation_time,json=creationTime,proto3" json:"creation_time,omitempty"`
}

func (m *UnbondingStakingQueueEntry) Reset()         { *m = UnbondingStakingQueueEntry{} }
func (m *UnbondingStakingQueueEntry) String() string { return proto.CompactTextString(m) }
func (*UnbondingStakingQueueEntry) ProtoMessage()    {}
func (*UnbondingStakingQueueEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_db13ea1584a90e6e, []int{10}
}
func (m *UnbondingStakingQueueEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnbondingStakingQueueEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnbondingStakingQueueEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnbondingStakingQueueEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnbondingStakingQueueEntry.Merge(m, src)
}
func (m *UnbondingStakingQueueEntry) XXX_Size() int {
	return m.Size()
}
func (m *UnbondingStakingQueueEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_UnbondingStakingQueueEntry.DiscardUnknown(m)
}

var xxx_messageInfo_UnbondingStakingQueueEntry proto.InternalMessageInfo

func (m *UnbondingStakingQueueEntry) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *UnbondingStakingQueueEntry) GetStaker() string {
	if m != nil {
		return m.Staker
	}
	return ""
}

func (m *UnbondingStakingQueueEntry) GetPoolId() uint64 {
	if m != nil {
		return m.PoolId
	}
	return 0
}

func (m *UnbondingStakingQueueEntry) GetAmount() uint64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *UnbondingStakingQueueEntry) GetCreationTime() uint64 {
	if m != nil {
		return m.CreationTime
	}
	return 0
}

// UnbondingStakingEntry
// Creates an entry for an upcoming unbonding of a staker which is put in the unbonding fifo queue and
// executed after the unbonding time is over.
type UnbondingStaker struct {
	// staker ...
	Staker string `protobuf:"bytes,1,opt,name=staker,proto3" json:"staker,omitempty"`
	// pool_id ...
	PoolId uint64 `protobuf:"varint,2,opt,name=pool_id,json=poolId,proto3" json:"pool_id,omitempty"`
	// amount ...
	UnbondingAmount uint64 `protobuf:"varint,3,opt,name=unbonding_amount,json=unbondingAmount,proto3" json:"unbonding_amount,omitempty"`
}

func (m *UnbondingStaker) Reset()         { *m = UnbondingStaker{} }
func (m *UnbondingStaker) String() string { return proto.CompactTextString(m) }
func (*UnbondingStaker) ProtoMessage()    {}
func (*UnbondingStaker) Descriptor() ([]byte, []int) {
	return fileDescriptor_db13ea1584a90e6e, []int{11}
}
func (m *UnbondingStaker) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnbondingStaker) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnbondingStaker.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnbondingStaker) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnbondingStaker.Merge(m, src)
}
func (m *UnbondingStaker) XXX_Size() int {
	return m.Size()
}
func (m *UnbondingStaker) XXX_DiscardUnknown() {
	xxx_messageInfo_UnbondingStaker.DiscardUnknown(m)
}

var xxx_messageInfo_UnbondingStaker proto.InternalMessageInfo

func (m *UnbondingStaker) GetStaker() string {
	if m != nil {
		return m.Staker
	}
	return ""
}

func (m *UnbondingStaker) GetPoolId() uint64 {
	if m != nil {
		return m.PoolId
	}
	return 0
}

func (m *UnbondingStaker) GetUnbondingAmount() uint64 {
	if m != nil {
		return m.UnbondingAmount
	}
	return 0
}

// UnbondingState stores the state for the unbonding of stakes and delegations.
type UnbondingStakingQueueState struct {
	// low_index ...
	LowIndex uint64 `protobuf:"varint,1,opt,name=low_index,json=lowIndex,proto3" json:"low_index,omitempty"`
	// high_index ...
	HighIndex uint64 `protobuf:"varint,2,opt,name=high_index,json=highIndex,proto3" json:"high_index,omitempty"`
}

func (m *UnbondingStakingQueueState) Reset()         { *m = UnbondingStakingQueueState{} }
func (m *UnbondingStakingQueueState) String() string { return proto.CompactTextString(m) }
func (*UnbondingStakingQueueState) ProtoMessage()    {}
func (*UnbondingStakingQueueState) Descriptor() ([]byte, []int) {
	return fileDescriptor_db13ea1584a90e6e, []int{12}
}
func (m *UnbondingStakingQueueState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnbondingStakingQueueState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnbondingStakingQueueState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnbondingStakingQueueState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnbondingStakingQueueState.Merge(m, src)
}
func (m *UnbondingStakingQueueState) XXX_Size() int {
	return m.Size()
}
func (m *UnbondingStakingQueueState) XXX_DiscardUnknown() {
	xxx_messageInfo_UnbondingStakingQueueState.DiscardUnknown(m)
}

var xxx_messageInfo_UnbondingStakingQueueState proto.InternalMessageInfo

func (m *UnbondingStakingQueueState) GetLowIndex() uint64 {
	if m != nil {
		return m.LowIndex
	}
	return 0
}

func (m *UnbondingStakingQueueState) GetHighIndex() uint64 {
	if m != nil {
		return m.HighIndex
	}
	return 0
}

// UnbondingStakingEntry
// Creates an entry for an upcoming unbonding of a staker which is put in the unbonding fifo queue and
// executed after the unbonding time is over.
type UnbondingDelegationQueueEntry struct {
	// index is a monotonically increasing integer to order the entries
	Index uint64 `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	// staker ...
	Staker string `protobuf:"bytes,2,opt,name=staker,proto3" json:"staker,omitempty"`
	// delegator ...
	Delegator string `protobuf:"bytes,3,opt,name=delegator,proto3" json:"delegator,omitempty"`
	// pool_id ...
	PoolId uint64 `protobuf:"varint,4,opt,name=pool_id,json=poolId,proto3" json:"pool_id,omitempty"`
	// amount ...
	Amount uint64 `protobuf:"varint,5,opt,name=amount,proto3" json:"amount,omitempty"`
	// creation_time ...
	CreationTime uint64 `protobuf:"varint,6,opt,name=creation_time,json=creationTime,proto3" json:"creation_time,omitempty"`
}

func (m *UnbondingDelegationQueueEntry) Reset()         { *m = UnbondingDelegationQueueEntry{} }
func (m *UnbondingDelegationQueueEntry) String() string { return proto.CompactTextString(m) }
func (*UnbondingDelegationQueueEntry) ProtoMessage()    {}
func (*UnbondingDelegationQueueEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_db13ea1584a90e6e, []int{13}
}
func (m *UnbondingDelegationQueueEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnbondingDelegationQueueEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnbondingDelegationQueueEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnbondingDelegationQueueEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnbondingDelegationQueueEntry.Merge(m, src)
}
func (m *UnbondingDelegationQueueEntry) XXX_Size() int {
	return m.Size()
}
func (m *UnbondingDelegationQueueEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_UnbondingDelegationQueueEntry.DiscardUnknown(m)
}

var xxx_messageInfo_UnbondingDelegationQueueEntry proto.InternalMessageInfo

func (m *UnbondingDelegationQueueEntry) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *UnbondingDelegationQueueEntry) GetStaker() string {
	if m != nil {
		return m.Staker
	}
	return ""
}

func (m *UnbondingDelegationQueueEntry) GetDelegator() string {
	if m != nil {
		return m.Delegator
	}
	return ""
}

func (m *UnbondingDelegationQueueEntry) GetPoolId() uint64 {
	if m != nil {
		return m.PoolId
	}
	return 0
}

func (m *UnbondingDelegationQueueEntry) GetAmount() uint64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *UnbondingDelegationQueueEntry) GetCreationTime() uint64 {
	if m != nil {
		return m.CreationTime
	}
	return 0
}

// UnbondingState stores the state for the unbonding of stakes and delegations.
type UnbondingDelegationQueueState struct {
	// low_index ...
	LowIndex uint64 `protobuf:"varint,1,opt,name=low_index,json=lowIndex,proto3" json:"low_index,omitempty"`
	// high_index ...
	HighIndex uint64 `protobuf:"varint,2,opt,name=high_index,json=highIndex,proto3" json:"high_index,omitempty"`
}

func (m *UnbondingDelegationQueueState) Reset()         { *m = UnbondingDelegationQueueState{} }
func (m *UnbondingDelegationQueueState) String() string { return proto.CompactTextString(m) }
func (*UnbondingDelegationQueueState) ProtoMessage()    {}
func (*UnbondingDelegationQueueState) Descriptor() ([]byte, []int) {
	return fileDescriptor_db13ea1584a90e6e, []int{14}
}
func (m *UnbondingDelegationQueueState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnbondingDelegationQueueState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnbondingDelegationQueueState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnbondingDelegationQueueState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnbondingDelegationQueueState.Merge(m, src)
}
func (m *UnbondingDelegationQueueState) XXX_Size() int {
	return m.Size()
}
func (m *UnbondingDelegationQueueState) XXX_DiscardUnknown() {
	xxx_messageInfo_UnbondingDelegationQueueState.DiscardUnknown(m)
}

var xxx_messageInfo_UnbondingDelegationQueueState proto.InternalMessageInfo

func (m *UnbondingDelegationQueueState) GetLowIndex() uint64 {
	if m != nil {
		return m.LowIndex
	}
	return 0
}

func (m *UnbondingDelegationQueueState) GetHighIndex() uint64 {
	if m != nil {
		return m.HighIndex
	}
	return 0
}

func init() {
	proto.RegisterType((*BundleProposal)(nil), "kyve.registry.v1beta1.BundleProposal")
	proto.RegisterType((*Protocol)(nil), "kyve.registry.v1beta1.Protocol")
	proto.RegisterType((*UpgradePlan)(nil), "kyve.registry.v1beta1.UpgradePlan")
	proto.RegisterType((*DelegationEntries)(nil), "kyve.registry.v1beta1.DelegationEntries")
	proto.RegisterType((*DelegationPoolData)(nil), "kyve.registry.v1beta1.DelegationPoolData")
	proto.RegisterType((*Delegator)(nil), "kyve.registry.v1beta1.Delegator")
	proto.RegisterType((*Funder)(nil), "kyve.registry.v1beta1.Funder")
	proto.RegisterType((*Pool)(nil), "kyve.registry.v1beta1.Pool")
	proto.RegisterType((*Proposal)(nil), "kyve.registry.v1beta1.Proposal")
	proto.RegisterType((*Staker)(nil), "kyve.registry.v1beta1.Staker")
	proto.RegisterType((*UnbondingStakingQueueEntry)(nil), "kyve.registry.v1beta1.UnbondingStakingQueueEntry")
	proto.RegisterType((*UnbondingStaker)(nil), "kyve.registry.v1beta1.UnbondingStaker")
	proto.RegisterType((*UnbondingStakingQueueState)(nil), "kyve.registry.v1beta1.UnbondingStakingQueueState")
	proto.RegisterType((*UnbondingDelegationQueueEntry)(nil), "kyve.registry.v1beta1.UnbondingDelegationQueueEntry")
	proto.RegisterType((*UnbondingDelegationQueueState)(nil), "kyve.registry.v1beta1.UnbondingDelegationQueueState")
}

func init() {
	proto.RegisterFile("kyve/registry/v1beta1/registry.proto", fileDescriptor_db13ea1584a90e6e)
}

var fileDescriptor_db13ea1584a90e6e = []byte{
	// 1465 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x57, 0x4f, 0x6f, 0xdb, 0xc6,
	0x12, 0x0f, 0x25, 0x59, 0x16, 0x47, 0xb2, 0xec, 0xf0, 0xe5, 0x0f, 0xe3, 0xc4, 0xb2, 0xa3, 0x24,
	0x2f, 0x7e, 0x78, 0x78, 0xf6, 0x4b, 0x7b, 0xec, 0xc9, 0x4e, 0xd2, 0xc6, 0x08, 0x10, 0xb8, 0x74,
	0x9d, 0xfe, 0x3b, 0x10, 0x2b, 0x71, 0x2d, 0x2d, 0x44, 0xed, 0x0a, 0xdc, 0xa5, 0x64, 0xe7, 0xd8,
	0x4f, 0xd0, 0x53, 0x7b, 0x2d, 0xf2, 0x09, 0xfa, 0x15, 0x7a, 0xeb, 0x31, 0xc7, 0x1e, 0x8b, 0xe4,
	0x7b, 0x14, 0xc5, 0xec, 0x2e, 0x29, 0xd2, 0x91, 0x8a, 0x22, 0xbd, 0x69, 0x7e, 0x1c, 0xcf, 0xce,
	0xce, 0xcc, 0xfe, 0x7e, 0x63, 0xb8, 0x3f, 0xba, 0x98, 0xd2, 0xfd, 0x84, 0x0e, 0x98, 0x54, 0xc9,
	0xc5, 0xfe, 0xf4, 0x51, 0x8f, 0x2a, 0xf2, 0x28, 0x07, 0xf6, 0x26, 0x89, 0x50, 0xc2, 0xbb, 0x8e,
	0x5e, 0x7b, 0x39, 0x68, 0xbd, 0xba, 0x3f, 0x57, 0xa1, 0x7d, 0x98, 0xf2, 0x28, 0xa6, 0xc7, 0x89,
	0x98, 0x08, 0x49, 0x62, 0x6f, 0x13, 0x1a, 0xe9, 0x24, 0x16, 0x24, 0xa2, 0x89, 0xef, 0xec, 0x38,
	0xbb, 0x6e, 0x90, 0xdb, 0xde, 0x3d, 0x58, 0xe3, 0xf4, 0x5c, 0x85, 0xb9, 0x43, 0x45, 0x3b, 0xb4,
	0x10, 0x3c, 0xcd, 0x9c, 0x6e, 0x83, 0xdb, 0xd3, 0x21, 0x43, 0x16, 0xf9, 0x55, 0x13, 0xc1, 0x00,
	0x47, 0x91, 0xfe, 0x78, 0xa1, 0x68, 0x28, 0xd9, 0x2b, 0xea, 0xd7, 0x76, 0x9c, 0xdd, 0x5a, 0xd0,
	0x40, 0xe0, 0x84, 0xbd, 0xa2, 0xde, 0x3d, 0x68, 0x9e, 0x25, 0x62, 0x1c, 0x0e, 0x29, 0x1b, 0x0c,
	0x95, 0xbf, 0x82, 0x9f, 0x0f, 0x2b, 0xbe, 0x13, 0x00, 0xc2, 0xcf, 0x34, 0x8a, 0x11, 0x94, 0xc8,
	0x5c, 0xea, 0x26, 0x82, 0x12, 0xf6, 0xe3, 0x16, 0x40, 0x3f, 0xa1, 0x44, 0xd1, 0x28, 0x24, 0xca,
	0x5f, 0xd5, 0x5f, 0x5d, 0x8b, 0x1c, 0x28, 0xef, 0x2e, 0xb4, 0xa6, 0x42, 0xd1, 0x44, 0x86, 0x53,
	0x12, 0xb3, 0xc8, 0x6f, 0xec, 0x54, 0x77, 0xdd, 0xa0, 0x69, 0xb0, 0x97, 0x08, 0x79, 0x0f, 0xa0,
	0x6d, 0x5d, 0x18, 0x37, 0x4e, 0xae, 0x76, 0x5a, 0x33, 0xe8, 0x91, 0x01, 0x0b, 0x6e, 0xa4, 0x27,
	0x15, 0x61, 0xdc, 0x87, 0xa2, 0xdb, 0x81, 0x01, 0xbd, 0xeb, 0x50, 0x57, 0x22, 0x1c, 0xd1, 0x0b,
	0xbf, 0xa9, 0x0b, 0xb1, 0xa2, 0xc4, 0x73, 0x7a, 0xe1, 0xdd, 0x82, 0x86, 0x12, 0x98, 0x43, 0x4a,
	0xfd, 0x96, 0xfe, 0xb0, 0xaa, 0xc4, 0x4b, 0x34, 0xbd, 0x6d, 0x68, 0xda, 0xea, 0x0d, 0x89, 0x1c,
	0xfa, 0x6b, 0xfa, 0x2b, 0x18, 0xe8, 0x19, 0x91, 0xc3, 0x6e, 0x1f, 0x1a, 0xc7, 0xd8, 0xd2, 0xbe,
	0x88, 0x3d, 0x1f, 0x56, 0xa7, 0x34, 0x91, 0x4c, 0x70, 0xdb, 0xaa, 0xcc, 0xc4, 0x2e, 0xf6, 0x18,
	0x27, 0x09, 0xa3, 0xd2, 0x36, 0x29, 0xb7, 0xb1, 0x0a, 0x31, 0x91, 0xd8, 0xc5, 0x41, 0x42, 0x22,
	0xaa, 0x7b, 0x54, 0x0b, 0x9a, 0x88, 0x9d, 0x1a, 0xa8, 0xfb, 0x9d, 0x03, 0x4d, 0xfb, 0xfb, 0x38,
	0x26, 0xfc, 0xc3, 0x0f, 0x92, 0xfd, 0x21, 0x8d, 0xd2, 0xd8, 0xf4, 0xc3, 0x1e, 0x94, 0x63, 0x07,
	0x0a, 0xff, 0x3c, 0x4a, 0x13, 0xa2, 0x30, 0xb2, 0x1d, 0x87, 0xcc, 0xee, 0x72, 0xb8, 0xfa, 0x84,
	0xc6, 0x74, 0xa0, 0xad, 0xa7, 0x5c, 0xe9, 0x98, 0x6d, 0xa8, 0xb0, 0x48, 0x27, 0x51, 0x0b, 0x2a,
	0x2c, 0xc2, 0xcc, 0x7a, 0x24, 0x26, 0xbc, 0x4f, 0xed, 0xf1, 0x99, 0xe9, 0xdd, 0x80, 0xba, 0x54,
	0x64, 0x44, 0x13, 0x3b, 0x84, 0xd6, 0xf2, 0x6e, 0xc2, 0xea, 0x28, 0x64, 0x3c, 0xa2, 0xe7, 0xf6,
	0xc4, 0xfa, 0xe8, 0x08, 0xad, 0xee, 0xeb, 0x0a, 0x78, 0xf3, 0x03, 0x8f, 0x85, 0x88, 0x9f, 0x10,
	0x45, 0xde, 0x3b, 0x71, 0x1e, 0xb7, 0x52, 0x8a, 0xfb, 0x10, 0xd6, 0xfb, 0x69, 0x92, 0x50, 0xae,
	0xc2, 0x84, 0xce, 0x48, 0x12, 0x49, 0x7b, 0xe1, 0xb6, 0x85, 0x03, 0x83, 0x7a, 0xff, 0x81, 0x0d,
	0x25, 0x14, 0x89, 0xc3, 0x28, 0x3f, 0xcc, 0x66, 0xb2, 0xae, 0xf1, 0x79, 0x0e, 0xde, 0x7d, 0x68,
	0xc7, 0x44, 0x51, 0xa9, 0x4c, 0xc2, 0xe1, 0xc8, 0x3c, 0x8a, 0xa0, 0x65, 0x50, 0x9d, 0xf7, 0x73,
	0x3c, 0xd9, 0x86, 0x12, 0x49, 0xd8, 0x17, 0x29, 0xcf, 0x1e, 0x46, 0x3b, 0x87, 0x1f, 0x23, 0xea,
	0x1d, 0xc0, 0x56, 0x29, 0xdc, 0x8c, 0xc8, 0x30, 0xe5, 0x85, 0x34, 0xf0, 0xc5, 0x34, 0x82, 0xcd,
	0x42, 0xf4, 0x2f, 0x89, 0x3c, 0x2d, 0x78, 0x74, 0x7f, 0x74, 0xc0, 0x7d, 0x92, 0x45, 0x7d, 0xaf,
	0x36, 0x85, 0xda, 0x56, 0x8a, 0xb5, 0xf5, 0xfe, 0x0b, 0x57, 0xe7, 0x41, 0x42, 0x32, 0xd6, 0x49,
	0x9a, 0xf2, 0x6c, 0xcc, 0x3f, 0x1c, 0x68, 0xbc, 0x50, 0xe1, 0x5a, 0xa9, 0xc2, 0x77, 0xc0, 0xcd,
	0x2f, 0xa4, 0x0b, 0xe1, 0x06, 0x73, 0xa0, 0x7b, 0x02, 0xf5, 0x4f, 0xf1, 0x32, 0x09, 0xce, 0x04,
	0xe9, 0x9b, 0x3a, 0xd8, 0x99, 0xb0, 0x26, 0xe6, 0x37, 0x11, 0x22, 0x0e, 0xf3, 0xa4, 0xeb, 0x68,
	0x1e, 0xe9, 0xa6, 0x96, 0x92, 0xb2, 0x56, 0xf7, 0x75, 0x03, 0x6a, 0x38, 0x09, 0x8b, 0xe6, 0x4e,
	0xf3, 0x8a, 0xc8, 0xc6, 0x20, 0x33, 0x3d, 0x0f, 0x6a, 0x9c, 0x8c, 0xa9, 0x9d, 0x3a, 0xfd, 0x1b,
	0xbd, 0x93, 0x94, 0x2b, 0x36, 0xa6, 0xf6, 0x4a, 0x99, 0x89, 0xde, 0xb1, 0x18, 0x08, 0x7b, 0x1d,
	0xfd, 0xdb, 0xeb, 0x40, 0xc3, 0x3e, 0x2f, 0xa9, 0x1b, 0xe9, 0x6a, 0x12, 0xcc, 0x31, 0x4c, 0xb6,
	0x2f, 0xf8, 0x19, 0x1b, 0xe8, 0x7e, 0xb9, 0x81, 0xb5, 0x90, 0x94, 0xb2, 0x09, 0xb4, 0xfc, 0xd8,
	0xd0, 0xf9, 0xae, 0x59, 0xd4, 0x92, 0xe4, 0x36, 0x34, 0xcd, 0xfc, 0x21, 0xf1, 0x4a, 0xdf, 0xd5,
	0x3e, 0xa0, 0xa1, 0x43, 0x44, 0x90, 0xe6, 0xad, 0x83, 0xa6, 0x1d, 0xe9, 0x83, 0x19, 0x3a, 0xe3,
	0x62, 0x30, 0xef, 0xff, 0x70, 0xad, 0xe8, 0x94, 0xcf, 0x7c, 0x53, 0xfb, 0x7a, 0x05, 0xdf, 0x6c,
	0xee, 0x1f, 0x40, 0x4b, 0x2a, 0x92, 0xe4, 0xc9, 0xb5, 0x72, 0x7e, 0x6f, 0x6a, 0xdc, 0xa6, 0xf7,
	0x10, 0xd6, 0x8d, 0xbe, 0x84, 0x8c, 0x2b, 0x9a, 0x4c, 0x49, 0xac, 0x59, 0xb0, 0x16, 0xb4, 0x0d,
	0x7c, 0x64, 0x51, 0xbc, 0xae, 0x98, 0x50, 0x24, 0x0b, 0x3e, 0x08, 0xfb, 0x42, 0x2a, 0xbf, 0x6d,
	0xae, 0x9b, 0xa3, 0x8f, 0x85, 0xd4, 0xd3, 0x34, 0x21, 0xa9, 0xa4, 0x91, 0xbf, 0xae, 0xa7, 0xdb,
	0x5a, 0xd8, 0x93, 0x33, 0x3d, 0x2f, 0xd2, 0xdf, 0xd0, 0xdc, 0x9d, 0x99, 0x78, 0xff, 0x58, 0xcc,
	0xf0, 0x99, 0x18, 0xc4, 0xbf, 0x6a, 0x64, 0xce, 0x80, 0x76, 0xc8, 0xf2, 0x2a, 0xa2, 0x8f, 0xf4,
	0xbd, 0x42, 0x15, 0xd1, 0x43, 0x62, 0x7c, 0x33, 0xb7, 0xd2, 0xff, 0x97, 0x89, 0x6f, 0xcd, 0x42,
	0x7c, 0x3b, 0xe6, 0xd7, 0x8a, 0xf1, 0x4f, 0xcc, 0xb0, 0xe7, 0xf1, 0xb5, 0x8f, 0x7f, 0xbd, 0x10,
	0x5f, 0x7b, 0x2c, 0xa4, 0x91, 0x1b, 0x8b, 0x69, 0xe4, 0x05, 0xac, 0xdb, 0x2e, 0x4d, 0xac, 0xcc,
	0xfb, 0x37, 0x77, 0x9c, 0xdd, 0xe6, 0x47, 0x0f, 0xf6, 0x16, 0xee, 0x05, 0x7b, 0xe5, 0x9d, 0x20,
	0x68, 0xf7, 0xca, 0x3b, 0xc2, 0xbf, 0x61, 0x7d, 0x4c, 0xce, 0xb3, 0xce, 0x6b, 0x2d, 0xf7, 0x4d,
	0xe9, 0xc7, 0xe4, 0xdc, 0xfc, 0xad, 0x16, 0xf4, 0x4f, 0xa0, 0x31, 0xb1, 0x5a, 0xe5, 0xdf, 0xd2,
	0x07, 0x6e, 0x2f, 0x39, 0x30, 0x93, 0xb4, 0x20, 0xff, 0x03, 0xef, 0x29, 0xb4, 0xac, 0x42, 0x85,
	0x93, 0x98, 0x70, 0x7f, 0x53, 0x07, 0xe8, 0x2e, 0x09, 0x50, 0x50, 0xab, 0xa0, 0x99, 0x16, 0xa4,
	0xeb, 0x36, 0xb8, 0x66, 0xea, 0x50, 0x85, 0x6f, 0x1b, 0x85, 0xd2, 0x00, 0x0a, 0xf1, 0x36, 0x34,
	0xb3, 0x17, 0x83, 0x9f, 0xef, 0x18, 0xb5, 0xb5, 0x10, 0x3a, 0xdc, 0x83, 0xec, 0xf1, 0x58, 0xb9,
	0xde, 0x32, 0xad, 0xb2, 0xa0, 0xd6, 0xec, 0xee, 0x0f, 0x15, 0xad, 0xc9, 0xa6, 0x36, 0xa5, 0xf5,
	0xc7, 0xb9, 0xb4, 0xfe, 0x14, 0xf8, 0xa7, 0x52, 0xe2, 0x9f, 0xe2, 0xd6, 0x55, 0xbd, 0xb4, 0x75,
	0x6d, 0x97, 0xd7, 0x22, 0x23, 0x15, 0x4b, 0x57, 0xa2, 0x95, 0x4b, 0x2b, 0xd1, 0x5d, 0x68, 0x9d,
	0x31, 0x4e, 0x62, 0xf6, 0xca, 0x88, 0xb0, 0x51, 0x86, 0x66, 0x8e, 0x1d, 0x28, 0xcb, 0x6d, 0xab,
	0x39, 0xb7, 0x6d, 0x40, 0x15, 0xab, 0xd1, 0xd0, 0x79, 0xe0, 0x4f, 0xef, 0x1a, 0xac, 0x98, 0xeb,
	0xbb, 0x66, 0x8d, 0x99, 0x2e, 0xda, 0x55, 0xe0, 0xbd, 0x5d, 0xe5, 0x0f, 0x07, 0xea, 0x76, 0x9c,
	0x0b, 0x9c, 0xec, 0x2c, 0xe5, 0xe4, 0xca, 0xdf, 0xe1, 0x64, 0x1c, 0xfc, 0x94, 0xf7, 0x04, 0x8f,
	0xf0, 0xdd, 0x5b, 0x0f, 0xab, 0x9f, 0x39, 0x6e, 0x95, 0xa4, 0x03, 0xd0, 0x17, 0xe3, 0x31, 0x93,
	0x7a, 0x75, 0x59, 0xb1, 0xed, 0xcd, 0x11, 0xcc, 0x6a, 0x2c, 0x38, 0xc3, 0x37, 0x58, 0x37, 0x59,
	0x59, 0x13, 0xbf, 0xcc, 0x68, 0x4f, 0x32, 0x45, 0x2d, 0xc9, 0x66, 0x66, 0xce, 0xd8, 0x8d, 0x02,
	0x63, 0x23, 0xc7, 0x08, 0xc6, 0x55, 0xc6, 0xa6, 0xd6, 0xea, 0xfe, 0xe4, 0xc0, 0xe6, 0x69, 0x96,
	0x13, 0x56, 0x82, 0xf1, 0xc1, 0xe7, 0x29, 0x4d, 0x29, 0xae, 0x33, 0xba, 0xac, 0x46, 0x2c, 0x8d,
	0xae, 0x18, 0x63, 0xe9, 0x82, 0x51, 0x28, 0x54, 0x75, 0x49, 0xa1, 0x6a, 0xa5, 0x42, 0xe1, 0xf0,
	0xa2, 0x28, 0xa1, 0xe4, 0x6a, 0xed, 0xb1, 0xcb, 0x43, 0x06, 0x7e, 0xc1, 0xc6, 0xb4, 0x3b, 0x86,
	0xf5, 0x52, 0x86, 0x34, 0x29, 0x24, 0xe0, 0x2c, 0x4b, 0xa0, 0xdc, 0xa9, 0x45, 0x1d, 0xa9, 0x2e,
	0xec, 0x48, 0xf7, 0xab, 0x25, 0x05, 0x39, 0x51, 0x44, 0x51, 0x9c, 0xe4, 0x58, 0xcc, 0xc2, 0x62,
	0x51, 0x1a, 0xb1, 0x98, 0x99, 0x1d, 0x62, 0x0b, 0x60, 0xc8, 0x06, 0xc3, 0xd2, 0x7e, 0xe1, 0x22,
	0x62, 0xd6, 0xb7, 0x5f, 0x1c, 0xd8, 0xca, 0x43, 0xcf, 0xc9, 0xef, 0x83, 0xcb, 0x5d, 0xda, 0x36,
	0xaa, 0x97, 0xb6, 0x8d, 0x62, 0x2d, 0x6a, 0x4b, 0x9a, 0xb1, 0xf2, 0xd7, 0xcd, 0xa8, 0x2f, 0x68,
	0xc6, 0xb7, 0xcb, 0xaf, 0xf0, 0x8f, 0x0b, 0x74, 0xf8, 0xd9, 0xaf, 0x6f, 0x3b, 0xce, 0x9b, 0xb7,
	0x1d, 0xe7, 0xf7, 0xb7, 0x1d, 0xe7, 0xfb, 0x77, 0x9d, 0x2b, 0x6f, 0xde, 0x75, 0xae, 0xfc, 0xf6,
	0xae, 0x73, 0xe5, 0x9b, 0xff, 0x0d, 0x98, 0x1a, 0xa6, 0xbd, 0xbd, 0xbe, 0x18, 0xef, 0x3f, 0xff,
	0xfa, 0xe5, 0xd3, 0x17, 0x54, 0xcd, 0x44, 0x32, 0xda, 0xef, 0x0f, 0x09, 0xe3, 0xfb, 0xe7, 0xf3,
	0xff, 0x2e, 0xd5, 0xc5, 0x84, 0xca, 0x5e, 0x5d, 0x73, 0xf4, 0xc7, 0x7f, 0x06, 0x00, 0x00, 0xff,
	0xff, 0x4b, 0x34, 0x58, 0x21, 0x7b, 0x0e, 0x00, 0x00,
}

func (m *BundleProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BundleProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BundleProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BundleHash) > 0 {
		i -= len(m.BundleHash)
		copy(dAtA[i:], m.BundleHash)
		i = encodeVarintRegistry(dAtA, i, uint64(len(m.BundleHash)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.ToValue) > 0 {
		i -= len(m.ToValue)
		copy(dAtA[i:], m.ToValue)
		i = encodeVarintRegistry(dAtA, i, uint64(len(m.ToValue)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.ToKey) > 0 {
		i -= len(m.ToKey)
		copy(dAtA[i:], m.ToKey)
		i = encodeVarintRegistry(dAtA, i, uint64(len(m.ToKey)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.VotersAbstain) > 0 {
		for iNdEx := len(m.VotersAbstain) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.VotersAbstain[iNdEx])
			copy(dAtA[i:], m.VotersAbstain[iNdEx])
			i = encodeVarintRegistry(dAtA, i, uint64(len(m.VotersAbstain[iNdEx])))
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.VotersInvalid) > 0 {
		for iNdEx := len(m.VotersInvalid) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.VotersInvalid[iNdEx])
			copy(dAtA[i:], m.VotersInvalid[iNdEx])
			i = encodeVarintRegistry(dAtA, i, uint64(len(m.VotersInvalid[iNdEx])))
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.VotersValid) > 0 {
		for iNdEx := len(m.VotersValid) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.VotersValid[iNdEx])
			copy(dAtA[i:], m.VotersValid[iNdEx])
			i = encodeVarintRegistry(dAtA, i, uint64(len(m.VotersValid[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if m.CreatedAt != 0 {
		i = encodeVarintRegistry(dAtA, i, uint64(m.CreatedAt))
		i--
		dAtA[i] = 0x38
	}
	if m.ToHeight != 0 {
		i = encodeVarintRegistry(dAtA, i, uint64(m.ToHeight))
		i--
		dAtA[i] = 0x30
	}
	if m.FromHeight != 0 {
		i = encodeVarintRegistry(dAtA, i, uint64(m.FromHeight))
		i--
		dAtA[i] = 0x28
	}
	if m.ByteSize != 0 {
		i = encodeVarintRegistry(dAtA, i, uint64(m.ByteSize))
		i--
		dAtA[i] = 0x20
	}
	if len(m.BundleId) > 0 {
		i -= len(m.BundleId)
		copy(dAtA[i:], m.BundleId)
		i = encodeVarintRegistry(dAtA, i, uint64(len(m.BundleId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.NextUploader) > 0 {
		i -= len(m.NextUploader)
		copy(dAtA[i:], m.NextUploader)
		i = encodeVarintRegistry(dAtA, i, uint64(len(m.NextUploader)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Uploader) > 0 {
		i -= len(m.Uploader)
		copy(dAtA[i:], m.Uploader)
		i = encodeVarintRegistry(dAtA, i, uint64(len(m.Uploader)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Protocol) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Protocol) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Protocol) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LastUpgrade != 0 {
		i = encodeVarintRegistry(dAtA, i, uint64(m.LastUpgrade))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Binaries) > 0 {
		i -= len(m.Binaries)
		copy(dAtA[i:], m.Binaries)
		i = encodeVarintRegistry(dAtA, i, uint64(len(m.Binaries)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintRegistry(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpgradePlan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpgradePlan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpgradePlan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Duration != 0 {
		i = encodeVarintRegistry(dAtA, i, uint64(m.Duration))
		i--
		dAtA[i] = 0x20
	}
	if m.ScheduledAt != 0 {
		i = encodeVarintRegistry(dAtA, i, uint64(m.ScheduledAt))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Binaries) > 0 {
		i -= len(m.Binaries)
		copy(dAtA[i:], m.Binaries)
		i = encodeVarintRegistry(dAtA, i, uint64(len(m.Binaries)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintRegistry(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DelegationEntries) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DelegationEntries) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DelegationEntries) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.KIndex != 0 {
		i = encodeVarintRegistry(dAtA, i, uint64(m.KIndex))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Staker) > 0 {
		i -= len(m.Staker)
		copy(dAtA[i:], m.Staker)
		i = encodeVarintRegistry(dAtA, i, uint64(len(m.Staker)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Balance) > 0 {
		i -= len(m.Balance)
		copy(dAtA[i:], m.Balance)
		i = encodeVarintRegistry(dAtA, i, uint64(len(m.Balance)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintRegistry(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DelegationPoolData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DelegationPoolData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DelegationPoolData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LatestIndexWasUndelegation {
		i--
		if m.LatestIndexWasUndelegation {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.DelegatorCount != 0 {
		i = encodeVarintRegistry(dAtA, i, uint64(m.DelegatorCount))
		i--
		dAtA[i] = 0x30
	}
	if m.LatestIndexK != 0 {
		i = encodeVarintRegistry(dAtA, i, uint64(m.LatestIndexK))
		i--
		dAtA[i] = 0x28
	}
	if m.TotalDelegation != 0 {
		i = encodeVarintRegistry(dAtA, i, uint64(m.TotalDelegation))
		i--
		dAtA[i] = 0x20
	}
	if m.CurrentRewards != 0 {
		i = encodeVarintRegistry(dAtA, i, uint64(m.CurrentRewards))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Staker) > 0 {
		i -= len(m.Staker)
		copy(dAtA[i:], m.Staker)
		i = encodeVarintRegistry(dAtA, i, uint64(len(m.Staker)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintRegistry(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Delegator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Delegator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Delegator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Delegator) > 0 {
		i -= len(m.Delegator)
		copy(dAtA[i:], m.Delegator)
		i = encodeVarintRegistry(dAtA, i, uint64(len(m.Delegator)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Staker) > 0 {
		i -= len(m.Staker)
		copy(dAtA[i:], m.Staker)
		i = encodeVarintRegistry(dAtA, i, uint64(len(m.Staker)))
		i--
		dAtA[i] = 0x22
	}
	if m.DelegationAmount != 0 {
		i = encodeVarintRegistry(dAtA, i, uint64(m.DelegationAmount))
		i--
		dAtA[i] = 0x18
	}
	if m.KIndex != 0 {
		i = encodeVarintRegistry(dAtA, i, uint64(m.KIndex))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintRegistry(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Funder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Funder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Funder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Amount != 0 {
		i = encodeVarintRegistry(dAtA, i, uint64(m.Amount))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Account) > 0 {
		i -= len(m.Account)
		copy(dAtA[i:], m.Account)
		i = encodeVarintRegistry(dAtA, i, uint64(len(m.Account)))
		i--
		dAtA[i] = 0x12
	}
	if m.PoolId != 0 {
		i = encodeVarintRegistry(dAtA, i, uint64(m.PoolId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Pool) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Pool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Pool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CurrentValue) > 0 {
		i -= len(m.CurrentValue)
		copy(dAtA[i:], m.CurrentValue)
		i = encodeVarintRegistry(dAtA, i, uint64(len(m.CurrentValue)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xea
	}
	if len(m.CurrentKey) > 0 {
		i -= len(m.CurrentKey)
		copy(dAtA[i:], m.CurrentKey)
		i = encodeVarintRegistry(dAtA, i, uint64(len(m.CurrentKey)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe2
	}
	if len(m.StartKey) > 0 {
		i -= len(m.StartKey)
		copy(dAtA[i:], m.StartKey)
		i = encodeVarintRegistry(dAtA, i, uint64(len(m.StartKey)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	if m.UpgradePlan != nil {
		{
			size, err := m.UpgradePlan.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRegistry(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	if m.Protocol != nil {
		{
			size, err := m.Protocol.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRegistry(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if m.MaxBundleSize != 0 {
		i = encodeVarintRegistry(dAtA, i, uint64(m.MaxBundleSize))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if m.BundleProposal != nil {
		{
			size, err := m.BundleProposal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRegistry(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if m.TotalDelegation != 0 {
		i = encodeVarintRegistry(dAtA, i, uint64(m.TotalDelegation))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.TotalStake != 0 {
		i = encodeVarintRegistry(dAtA, i, uint64(m.TotalStake))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if len(m.LowestStaker) > 0 {
		i -= len(m.LowestStaker)
		copy(dAtA[i:], m.LowestStaker)
		i = encodeVarintRegistry(dAtA, i, uint64(len(m.LowestStaker)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if len(m.Stakers) > 0 {
		for iNdEx := len(m.Stakers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Stakers[iNdEx])
			copy(dAtA[i:], m.Stakers[iNdEx])
			i = encodeVarintRegistry(dAtA, i, uint64(len(m.Stakers[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x9a
		}
	}
	if m.TotalFunds != 0 {
		i = encodeVarintRegistry(dAtA, i, uint64(m.TotalFunds))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if len(m.LowestFunder) > 0 {
		i -= len(m.LowestFunder)
		copy(dAtA[i:], m.LowestFunder)
		i = encodeVarintRegistry(dAtA, i, uint64(len(m.LowestFunder)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.Funders) > 0 {
		for iNdEx := len(m.Funders) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Funders[iNdEx])
			copy(dAtA[i:], m.Funders[iNdEx])
			i = encodeVarintRegistry(dAtA, i, uint64(len(m.Funders[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if m.Paused {
		i--
		if m.Paused {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x78
	}
	if m.OperatingCost != 0 {
		i = encodeVarintRegistry(dAtA, i, uint64(m.OperatingCost))
		i--
		dAtA[i] = 0x70
	}
	if m.UploadInterval != 0 {
		i = encodeVarintRegistry(dAtA, i, uint64(m.UploadInterval))
		i--
		dAtA[i] = 0x68
	}
	if m.StartHeight != 0 {
		i = encodeVarintRegistry(dAtA, i, uint64(m.StartHeight))
		i--
		dAtA[i] = 0x60
	}
	if m.TotalBundleRewards != 0 {
		i = encodeVarintRegistry(dAtA, i, uint64(m.TotalBundleRewards))
		i--
		dAtA[i] = 0x58
	}
	if m.TotalBundles != 0 {
		i = encodeVarintRegistry(dAtA, i, uint64(m.TotalBundles))
		i--
		dAtA[i] = 0x50
	}
	if m.TotalBytes != 0 {
		i = encodeVarintRegistry(dAtA, i, uint64(m.TotalBytes))
		i--
		dAtA[i] = 0x48
	}
	if m.CurrentHeight != 0 {
		i = encodeVarintRegistry(dAtA, i, uint64(m.CurrentHeight))
		i--
		dAtA[i] = 0x40
	}
	if len(m.Config) > 0 {
		i -= len(m.Config)
		copy(dAtA[i:], m.Config)
		i = encodeVarintRegistry(dAtA, i, uint64(len(m.Config)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Versions) > 0 {
		i -= len(m.Versions)
		copy(dAtA[i:], m.Versions)
		i = encodeVarintRegistry(dAtA, i, uint64(len(m.Versions)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Logo) > 0 {
		i -= len(m.Logo)
		copy(dAtA[i:], m.Logo)
		i = encodeVarintRegistry(dAtA, i, uint64(len(m.Logo)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Runtime) > 0 {
		i -= len(m.Runtime)
		copy(dAtA[i:], m.Runtime)
		i = encodeVarintRegistry(dAtA, i, uint64(len(m.Runtime)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintRegistry(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintRegistry(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintRegistry(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Proposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Proposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Proposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BundleHash) > 0 {
		i -= len(m.BundleHash)
		copy(dAtA[i:], m.BundleHash)
		i = encodeVarintRegistry(dAtA, i, uint64(len(m.BundleHash)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintRegistry(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintRegistry(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x42
	}
	if m.Id != 0 {
		i = encodeVarintRegistry(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x38
	}
	if m.FinalizedAt != 0 {
		i = encodeVarintRegistry(dAtA, i, uint64(m.FinalizedAt))
		i--
		dAtA[i] = 0x30
	}
	if m.ToHeight != 0 {
		i = encodeVarintRegistry(dAtA, i, uint64(m.ToHeight))
		i--
		dAtA[i] = 0x28
	}
	if m.FromHeight != 0 {
		i = encodeVarintRegistry(dAtA, i, uint64(m.FromHeight))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Uploader) > 0 {
		i -= len(m.Uploader)
		copy(dAtA[i:], m.Uploader)
		i = encodeVarintRegistry(dAtA, i, uint64(len(m.Uploader)))
		i--
		dAtA[i] = 0x1a
	}
	if m.PoolId != 0 {
		i = encodeVarintRegistry(dAtA, i, uint64(m.PoolId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.BundleId) > 0 {
		i -= len(m.BundleId)
		copy(dAtA[i:], m.BundleId)
		i = encodeVarintRegistry(dAtA, i, uint64(len(m.BundleId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Staker) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Staker) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Staker) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Points != 0 {
		i = encodeVarintRegistry(dAtA, i, uint64(m.Points))
		i--
		dAtA[i] = 0x48
	}
	if len(m.Logo) > 0 {
		i -= len(m.Logo)
		copy(dAtA[i:], m.Logo)
		i = encodeVarintRegistry(dAtA, i, uint64(len(m.Logo)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Website) > 0 {
		i -= len(m.Website)
		copy(dAtA[i:], m.Website)
		i = encodeVarintRegistry(dAtA, i, uint64(len(m.Website)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Moniker) > 0 {
		i -= len(m.Moniker)
		copy(dAtA[i:], m.Moniker)
		i = encodeVarintRegistry(dAtA, i, uint64(len(m.Moniker)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Commission) > 0 {
		i -= len(m.Commission)
		copy(dAtA[i:], m.Commission)
		i = encodeVarintRegistry(dAtA, i, uint64(len(m.Commission)))
		i--
		dAtA[i] = 0x2a
	}
	if m.UnbondingAmount != 0 {
		i = encodeVarintRegistry(dAtA, i, uint64(m.UnbondingAmount))
		i--
		dAtA[i] = 0x20
	}
	if m.Amount != 0 {
		i = encodeVarintRegistry(dAtA, i, uint64(m.Amount))
		i--
		dAtA[i] = 0x18
	}
	if m.PoolId != 0 {
		i = encodeVarintRegistry(dAtA, i, uint64(m.PoolId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Account) > 0 {
		i -= len(m.Account)
		copy(dAtA[i:], m.Account)
		i = encodeVarintRegistry(dAtA, i, uint64(len(m.Account)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UnbondingStakingQueueEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnbondingStakingQueueEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnbondingStakingQueueEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CreationTime != 0 {
		i = encodeVarintRegistry(dAtA, i, uint64(m.CreationTime))
		i--
		dAtA[i] = 0x28
	}
	if m.Amount != 0 {
		i = encodeVarintRegistry(dAtA, i, uint64(m.Amount))
		i--
		dAtA[i] = 0x20
	}
	if m.PoolId != 0 {
		i = encodeVarintRegistry(dAtA, i, uint64(m.PoolId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Staker) > 0 {
		i -= len(m.Staker)
		copy(dAtA[i:], m.Staker)
		i = encodeVarintRegistry(dAtA, i, uint64(len(m.Staker)))
		i--
		dAtA[i] = 0x12
	}
	if m.Index != 0 {
		i = encodeVarintRegistry(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UnbondingStaker) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnbondingStaker) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnbondingStaker) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UnbondingAmount != 0 {
		i = encodeVarintRegistry(dAtA, i, uint64(m.UnbondingAmount))
		i--
		dAtA[i] = 0x18
	}
	if m.PoolId != 0 {
		i = encodeVarintRegistry(dAtA, i, uint64(m.PoolId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Staker) > 0 {
		i -= len(m.Staker)
		copy(dAtA[i:], m.Staker)
		i = encodeVarintRegistry(dAtA, i, uint64(len(m.Staker)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UnbondingStakingQueueState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnbondingStakingQueueState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnbondingStakingQueueState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.HighIndex != 0 {
		i = encodeVarintRegistry(dAtA, i, uint64(m.HighIndex))
		i--
		dAtA[i] = 0x10
	}
	if m.LowIndex != 0 {
		i = encodeVarintRegistry(dAtA, i, uint64(m.LowIndex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UnbondingDelegationQueueEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnbondingDelegationQueueEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnbondingDelegationQueueEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CreationTime != 0 {
		i = encodeVarintRegistry(dAtA, i, uint64(m.CreationTime))
		i--
		dAtA[i] = 0x30
	}
	if m.Amount != 0 {
		i = encodeVarintRegistry(dAtA, i, uint64(m.Amount))
		i--
		dAtA[i] = 0x28
	}
	if m.PoolId != 0 {
		i = encodeVarintRegistry(dAtA, i, uint64(m.PoolId))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Delegator) > 0 {
		i -= len(m.Delegator)
		copy(dAtA[i:], m.Delegator)
		i = encodeVarintRegistry(dAtA, i, uint64(len(m.Delegator)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Staker) > 0 {
		i -= len(m.Staker)
		copy(dAtA[i:], m.Staker)
		i = encodeVarintRegistry(dAtA, i, uint64(len(m.Staker)))
		i--
		dAtA[i] = 0x12
	}
	if m.Index != 0 {
		i = encodeVarintRegistry(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UnbondingDelegationQueueState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnbondingDelegationQueueState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnbondingDelegationQueueState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.HighIndex != 0 {
		i = encodeVarintRegistry(dAtA, i, uint64(m.HighIndex))
		i--
		dAtA[i] = 0x10
	}
	if m.LowIndex != 0 {
		i = encodeVarintRegistry(dAtA, i, uint64(m.LowIndex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintRegistry(dAtA []byte, offset int, v uint64) int {
	offset -= sovRegistry(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *BundleProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Uploader)
	if l > 0 {
		n += 1 + l + sovRegistry(uint64(l))
	}
	l = len(m.NextUploader)
	if l > 0 {
		n += 1 + l + sovRegistry(uint64(l))
	}
	l = len(m.BundleId)
	if l > 0 {
		n += 1 + l + sovRegistry(uint64(l))
	}
	if m.ByteSize != 0 {
		n += 1 + sovRegistry(uint64(m.ByteSize))
	}
	if m.FromHeight != 0 {
		n += 1 + sovRegistry(uint64(m.FromHeight))
	}
	if m.ToHeight != 0 {
		n += 1 + sovRegistry(uint64(m.ToHeight))
	}
	if m.CreatedAt != 0 {
		n += 1 + sovRegistry(uint64(m.CreatedAt))
	}
	if len(m.VotersValid) > 0 {
		for _, s := range m.VotersValid {
			l = len(s)
			n += 1 + l + sovRegistry(uint64(l))
		}
	}
	if len(m.VotersInvalid) > 0 {
		for _, s := range m.VotersInvalid {
			l = len(s)
			n += 1 + l + sovRegistry(uint64(l))
		}
	}
	if len(m.VotersAbstain) > 0 {
		for _, s := range m.VotersAbstain {
			l = len(s)
			n += 1 + l + sovRegistry(uint64(l))
		}
	}
	l = len(m.ToKey)
	if l > 0 {
		n += 1 + l + sovRegistry(uint64(l))
	}
	l = len(m.ToValue)
	if l > 0 {
		n += 1 + l + sovRegistry(uint64(l))
	}
	l = len(m.BundleHash)
	if l > 0 {
		n += 1 + l + sovRegistry(uint64(l))
	}
	return n
}

func (m *Protocol) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovRegistry(uint64(l))
	}
	l = len(m.Binaries)
	if l > 0 {
		n += 1 + l + sovRegistry(uint64(l))
	}
	if m.LastUpgrade != 0 {
		n += 1 + sovRegistry(uint64(m.LastUpgrade))
	}
	return n
}

func (m *UpgradePlan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovRegistry(uint64(l))
	}
	l = len(m.Binaries)
	if l > 0 {
		n += 1 + l + sovRegistry(uint64(l))
	}
	if m.ScheduledAt != 0 {
		n += 1 + sovRegistry(uint64(m.ScheduledAt))
	}
	if m.Duration != 0 {
		n += 1 + sovRegistry(uint64(m.Duration))
	}
	return n
}

func (m *DelegationEntries) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovRegistry(uint64(m.Id))
	}
	l = len(m.Balance)
	if l > 0 {
		n += 1 + l + sovRegistry(uint64(l))
	}
	l = len(m.Staker)
	if l > 0 {
		n += 1 + l + sovRegistry(uint64(l))
	}
	if m.KIndex != 0 {
		n += 1 + sovRegistry(uint64(m.KIndex))
	}
	return n
}

func (m *DelegationPoolData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovRegistry(uint64(m.Id))
	}
	l = len(m.Staker)
	if l > 0 {
		n += 1 + l + sovRegistry(uint64(l))
	}
	if m.CurrentRewards != 0 {
		n += 1 + sovRegistry(uint64(m.CurrentRewards))
	}
	if m.TotalDelegation != 0 {
		n += 1 + sovRegistry(uint64(m.TotalDelegation))
	}
	if m.LatestIndexK != 0 {
		n += 1 + sovRegistry(uint64(m.LatestIndexK))
	}
	if m.DelegatorCount != 0 {
		n += 1 + sovRegistry(uint64(m.DelegatorCount))
	}
	if m.LatestIndexWasUndelegation {
		n += 2
	}
	return n
}

func (m *Delegator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovRegistry(uint64(m.Id))
	}
	if m.KIndex != 0 {
		n += 1 + sovRegistry(uint64(m.KIndex))
	}
	if m.DelegationAmount != 0 {
		n += 1 + sovRegistry(uint64(m.DelegationAmount))
	}
	l = len(m.Staker)
	if l > 0 {
		n += 1 + l + sovRegistry(uint64(l))
	}
	l = len(m.Delegator)
	if l > 0 {
		n += 1 + l + sovRegistry(uint64(l))
	}
	return n
}

func (m *Funder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PoolId != 0 {
		n += 1 + sovRegistry(uint64(m.PoolId))
	}
	l = len(m.Account)
	if l > 0 {
		n += 1 + l + sovRegistry(uint64(l))
	}
	if m.Amount != 0 {
		n += 1 + sovRegistry(uint64(m.Amount))
	}
	return n
}

func (m *Pool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovRegistry(uint64(m.Id))
	}
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovRegistry(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovRegistry(uint64(l))
	}
	l = len(m.Runtime)
	if l > 0 {
		n += 1 + l + sovRegistry(uint64(l))
	}
	l = len(m.Logo)
	if l > 0 {
		n += 1 + l + sovRegistry(uint64(l))
	}
	l = len(m.Versions)
	if l > 0 {
		n += 1 + l + sovRegistry(uint64(l))
	}
	l = len(m.Config)
	if l > 0 {
		n += 1 + l + sovRegistry(uint64(l))
	}
	if m.CurrentHeight != 0 {
		n += 1 + sovRegistry(uint64(m.CurrentHeight))
	}
	if m.TotalBytes != 0 {
		n += 1 + sovRegistry(uint64(m.TotalBytes))
	}
	if m.TotalBundles != 0 {
		n += 1 + sovRegistry(uint64(m.TotalBundles))
	}
	if m.TotalBundleRewards != 0 {
		n += 1 + sovRegistry(uint64(m.TotalBundleRewards))
	}
	if m.StartHeight != 0 {
		n += 1 + sovRegistry(uint64(m.StartHeight))
	}
	if m.UploadInterval != 0 {
		n += 1 + sovRegistry(uint64(m.UploadInterval))
	}
	if m.OperatingCost != 0 {
		n += 1 + sovRegistry(uint64(m.OperatingCost))
	}
	if m.Paused {
		n += 2
	}
	if len(m.Funders) > 0 {
		for _, s := range m.Funders {
			l = len(s)
			n += 2 + l + sovRegistry(uint64(l))
		}
	}
	l = len(m.LowestFunder)
	if l > 0 {
		n += 2 + l + sovRegistry(uint64(l))
	}
	if m.TotalFunds != 0 {
		n += 2 + sovRegistry(uint64(m.TotalFunds))
	}
	if len(m.Stakers) > 0 {
		for _, s := range m.Stakers {
			l = len(s)
			n += 2 + l + sovRegistry(uint64(l))
		}
	}
	l = len(m.LowestStaker)
	if l > 0 {
		n += 2 + l + sovRegistry(uint64(l))
	}
	if m.TotalStake != 0 {
		n += 2 + sovRegistry(uint64(m.TotalStake))
	}
	if m.TotalDelegation != 0 {
		n += 2 + sovRegistry(uint64(m.TotalDelegation))
	}
	if m.BundleProposal != nil {
		l = m.BundleProposal.Size()
		n += 2 + l + sovRegistry(uint64(l))
	}
	if m.MaxBundleSize != 0 {
		n += 2 + sovRegistry(uint64(m.MaxBundleSize))
	}
	if m.Protocol != nil {
		l = m.Protocol.Size()
		n += 2 + l + sovRegistry(uint64(l))
	}
	if m.UpgradePlan != nil {
		l = m.UpgradePlan.Size()
		n += 2 + l + sovRegistry(uint64(l))
	}
	l = len(m.StartKey)
	if l > 0 {
		n += 2 + l + sovRegistry(uint64(l))
	}
	l = len(m.CurrentKey)
	if l > 0 {
		n += 2 + l + sovRegistry(uint64(l))
	}
	l = len(m.CurrentValue)
	if l > 0 {
		n += 2 + l + sovRegistry(uint64(l))
	}
	return n
}

func (m *Proposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BundleId)
	if l > 0 {
		n += 1 + l + sovRegistry(uint64(l))
	}
	if m.PoolId != 0 {
		n += 1 + sovRegistry(uint64(m.PoolId))
	}
	l = len(m.Uploader)
	if l > 0 {
		n += 1 + l + sovRegistry(uint64(l))
	}
	if m.FromHeight != 0 {
		n += 1 + sovRegistry(uint64(m.FromHeight))
	}
	if m.ToHeight != 0 {
		n += 1 + sovRegistry(uint64(m.ToHeight))
	}
	if m.FinalizedAt != 0 {
		n += 1 + sovRegistry(uint64(m.FinalizedAt))
	}
	if m.Id != 0 {
		n += 1 + sovRegistry(uint64(m.Id))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovRegistry(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovRegistry(uint64(l))
	}
	l = len(m.BundleHash)
	if l > 0 {
		n += 1 + l + sovRegistry(uint64(l))
	}
	return n
}

func (m *Staker) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Account)
	if l > 0 {
		n += 1 + l + sovRegistry(uint64(l))
	}
	if m.PoolId != 0 {
		n += 1 + sovRegistry(uint64(m.PoolId))
	}
	if m.Amount != 0 {
		n += 1 + sovRegistry(uint64(m.Amount))
	}
	if m.UnbondingAmount != 0 {
		n += 1 + sovRegistry(uint64(m.UnbondingAmount))
	}
	l = len(m.Commission)
	if l > 0 {
		n += 1 + l + sovRegistry(uint64(l))
	}
	l = len(m.Moniker)
	if l > 0 {
		n += 1 + l + sovRegistry(uint64(l))
	}
	l = len(m.Website)
	if l > 0 {
		n += 1 + l + sovRegistry(uint64(l))
	}
	l = len(m.Logo)
	if l > 0 {
		n += 1 + l + sovRegistry(uint64(l))
	}
	if m.Points != 0 {
		n += 1 + sovRegistry(uint64(m.Points))
	}
	return n
}

func (m *UnbondingStakingQueueEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovRegistry(uint64(m.Index))
	}
	l = len(m.Staker)
	if l > 0 {
		n += 1 + l + sovRegistry(uint64(l))
	}
	if m.PoolId != 0 {
		n += 1 + sovRegistry(uint64(m.PoolId))
	}
	if m.Amount != 0 {
		n += 1 + sovRegistry(uint64(m.Amount))
	}
	if m.CreationTime != 0 {
		n += 1 + sovRegistry(uint64(m.CreationTime))
	}
	return n
}

func (m *UnbondingStaker) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Staker)
	if l > 0 {
		n += 1 + l + sovRegistry(uint64(l))
	}
	if m.PoolId != 0 {
		n += 1 + sovRegistry(uint64(m.PoolId))
	}
	if m.UnbondingAmount != 0 {
		n += 1 + sovRegistry(uint64(m.UnbondingAmount))
	}
	return n
}

func (m *UnbondingStakingQueueState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LowIndex != 0 {
		n += 1 + sovRegistry(uint64(m.LowIndex))
	}
	if m.HighIndex != 0 {
		n += 1 + sovRegistry(uint64(m.HighIndex))
	}
	return n
}

func (m *UnbondingDelegationQueueEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovRegistry(uint64(m.Index))
	}
	l = len(m.Staker)
	if l > 0 {
		n += 1 + l + sovRegistry(uint64(l))
	}
	l = len(m.Delegator)
	if l > 0 {
		n += 1 + l + sovRegistry(uint64(l))
	}
	if m.PoolId != 0 {
		n += 1 + sovRegistry(uint64(m.PoolId))
	}
	if m.Amount != 0 {
		n += 1 + sovRegistry(uint64(m.Amount))
	}
	if m.CreationTime != 0 {
		n += 1 + sovRegistry(uint64(m.CreationTime))
	}
	return n
}

func (m *UnbondingDelegationQueueState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LowIndex != 0 {
		n += 1 + sovRegistry(uint64(m.LowIndex))
	}
	if m.HighIndex != 0 {
		n += 1 + sovRegistry(uint64(m.HighIndex))
	}
	return n
}

func sovRegistry(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozRegistry(x uint64) (n int) {
	return sovRegistry(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *BundleProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRegistry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BundleProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BundleProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uploader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegistry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegistry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uploader = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextUploader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegistry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegistry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextUploader = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BundleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegistry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegistry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BundleId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ByteSize", wireType)
			}
			m.ByteSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ByteSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromHeight", wireType)
			}
			m.FromHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToHeight", wireType)
			}
			m.ToHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ToHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			m.CreatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedAt |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VotersValid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegistry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegistry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VotersValid = append(m.VotersValid, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VotersInvalid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegistry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegistry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VotersInvalid = append(m.VotersInvalid, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VotersAbstain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegistry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegistry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VotersAbstain = append(m.VotersAbstain, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegistry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegistry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegistry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegistry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToValue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BundleHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegistry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegistry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BundleHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRegistry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRegistry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Protocol) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRegistry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Protocol: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Protocol: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegistry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegistry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Binaries", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegistry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegistry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Binaries = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpgrade", wireType)
			}
			m.LastUpgrade = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastUpgrade |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRegistry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRegistry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpgradePlan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRegistry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpgradePlan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpgradePlan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegistry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegistry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Binaries", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegistry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegistry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Binaries = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScheduledAt", wireType)
			}
			m.ScheduledAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ScheduledAt |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRegistry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRegistry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DelegationEntries) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRegistry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DelegationEntries: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DelegationEntries: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balance", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegistry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegistry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Balance = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Staker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegistry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegistry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Staker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KIndex", wireType)
			}
			m.KIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRegistry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRegistry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DelegationPoolData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRegistry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DelegationPoolData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DelegationPoolData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Staker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegistry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegistry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Staker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentRewards", wireType)
			}
			m.CurrentRewards = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentRewards |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalDelegation", wireType)
			}
			m.TotalDelegation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalDelegation |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestIndexK", wireType)
			}
			m.LatestIndexK = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LatestIndexK |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegatorCount", wireType)
			}
			m.DelegatorCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DelegatorCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestIndexWasUndelegation", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LatestIndexWasUndelegation = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRegistry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRegistry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Delegator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRegistry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Delegator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Delegator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KIndex", wireType)
			}
			m.KIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegationAmount", wireType)
			}
			m.DelegationAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DelegationAmount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Staker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegistry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegistry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Staker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delegator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegistry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegistry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Delegator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRegistry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRegistry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Funder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRegistry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Funder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Funder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
			}
			m.PoolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Account", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegistry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegistry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Account = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			m.Amount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRegistry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRegistry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Pool) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRegistry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Pool: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Pool: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegistry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegistry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegistry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegistry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Runtime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegistry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegistry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Runtime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Logo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegistry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegistry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Logo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Versions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegistry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegistry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Versions = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegistry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegistry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Config = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentHeight", wireType)
			}
			m.CurrentHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalBytes", wireType)
			}
			m.TotalBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalBundles", wireType)
			}
			m.TotalBundles = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalBundles |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalBundleRewards", wireType)
			}
			m.TotalBundleRewards = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalBundleRewards |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartHeight", wireType)
			}
			m.StartHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadInterval", wireType)
			}
			m.UploadInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UploadInterval |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatingCost", wireType)
			}
			m.OperatingCost = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperatingCost |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paused", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Paused = bool(v != 0)
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Funders", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegistry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegistry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Funders = append(m.Funders, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LowestFunder", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegistry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegistry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LowestFunder = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalFunds", wireType)
			}
			m.TotalFunds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalFunds |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stakers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegistry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegistry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stakers = append(m.Stakers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LowestStaker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegistry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegistry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LowestStaker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalStake", wireType)
			}
			m.TotalStake = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalStake |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalDelegation", wireType)
			}
			m.TotalDelegation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalDelegation |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BundleProposal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRegistry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRegistry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BundleProposal == nil {
				m.BundleProposal = &BundleProposal{}
			}
			if err := m.BundleProposal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxBundleSize", wireType)
			}
			m.MaxBundleSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxBundleSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRegistry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRegistry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Protocol == nil {
				m.Protocol = &Protocol{}
			}
			if err := m.Protocol.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpgradePlan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRegistry
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRegistry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpgradePlan == nil {
				m.UpgradePlan = &UpgradePlan{}
			}
			if err := m.UpgradePlan.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegistry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegistry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegistry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegistry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CurrentKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegistry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegistry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CurrentValue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRegistry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRegistry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Proposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRegistry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Proposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Proposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BundleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegistry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegistry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BundleId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
			}
			m.PoolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uploader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegistry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegistry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uploader = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromHeight", wireType)
			}
			m.FromHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToHeight", wireType)
			}
			m.ToHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ToHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinalizedAt", wireType)
			}
			m.FinalizedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FinalizedAt |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegistry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegistry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegistry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegistry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BundleHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegistry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegistry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BundleHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRegistry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRegistry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Staker) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRegistry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Staker: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Staker: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Account", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegistry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegistry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Account = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
			}
			m.PoolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			m.Amount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnbondingAmount", wireType)
			}
			m.UnbondingAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnbondingAmount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commission", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegistry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegistry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Commission = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Moniker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegistry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegistry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Moniker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Website", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegistry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegistry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Website = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Logo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegistry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegistry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Logo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Points", wireType)
			}
			m.Points = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Points |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRegistry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRegistry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnbondingStakingQueueEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRegistry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnbondingStakingQueueEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnbondingStakingQueueEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Staker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegistry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegistry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Staker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
			}
			m.PoolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			m.Amount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreationTime", wireType)
			}
			m.CreationTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreationTime |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRegistry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRegistry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnbondingStaker) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRegistry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnbondingStaker: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnbondingStaker: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Staker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegistry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegistry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Staker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
			}
			m.PoolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnbondingAmount", wireType)
			}
			m.UnbondingAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnbondingAmount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRegistry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRegistry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnbondingStakingQueueState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRegistry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnbondingStakingQueueState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnbondingStakingQueueState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LowIndex", wireType)
			}
			m.LowIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LowIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighIndex", wireType)
			}
			m.HighIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HighIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRegistry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRegistry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnbondingDelegationQueueEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRegistry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnbondingDelegationQueueEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnbondingDelegationQueueEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Staker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegistry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegistry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Staker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delegator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegistry
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegistry
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Delegator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
			}
			m.PoolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			m.Amount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreationTime", wireType)
			}
			m.CreationTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreationTime |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRegistry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRegistry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnbondingDelegationQueueState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRegistry
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnbondingDelegationQueueState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnbondingDelegationQueueState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LowIndex", wireType)
			}
			m.LowIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LowIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighIndex", wireType)
			}
			m.HighIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HighIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRegistry(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRegistry
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRegistry(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRegistry
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRegistry
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthRegistry
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupRegistry
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthRegistry
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthRegistry        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRegistry          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupRegistry = fmt.Errorf("proto: unexpected end of group")
)
